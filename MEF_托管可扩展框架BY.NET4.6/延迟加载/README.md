## 延迟加载

	有的时候，有些组件的创建开销比较大，但又不会立即使用。

	此时，我们希望通过延迟初始化的方式将其延迟到使用的时候创建

	从而提高性能（常见的是提高启动速度）。


#### 简单的延迟加载

	1.  接收组件的类型 T 变为 Lazy<T>
	2.  用Value调用组件
	3.	组件被发现时并不初始化，会在第一次被调用时进行初始化

#### 多组件延迟加载
	 
	1. 多组件时，为了区分功能不同的组件，需要获取组件信息，但同时也触发了组件的初始化，失去了延迟加载的意义
	2. 为组件附加信息，加载时只获取附加信息而不初始化组件，来实现区分功能同时延迟加载。

	方法1：

		新创建一个接口，导出组件同时附加新接口的键值对，键对应接口中的属性名，值对应组件的识别内容

		加载组件时，变为 public Lazy<Person, PersonData>[] y 
		PersonData为附加信息，y[0].Metadata.Name 就是组件的识别符
		这样 Person 并没有被调用，也就不会被加载

		这个方法的优点是简单直观，对于少量组件很方便
		缺点也很致命，键输错导至不能附加信息，非常不容易定位到错误
		附加的属性多时，会有大量重复书写，不易维护修改

	方法2：
		声明一个LoggerDataAttribute，这个Attribute必须被MetadataAttribute标记。
		然后，在Export的对象前加上该LoggerDataAttribute，这样MEF导入的时候就会根据该LoggerDataAttribute创建元数据了。

		这里的LoggerDataAttribute本身并不需要实现ILoggerData接口，它是一个DuckType的约定，只需要实现元数据的属性即可。
		我这里实现该接口主要是为了让编译器保障元数据属性都有被准确实现。
		
		麻烦点~但安全